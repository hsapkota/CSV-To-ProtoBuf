syntax = "proto3";

message BottleneckLog {
    /*
        1 - 14 are the transfer metrics. It is generated by some computation using the
        values generated using "ss -t -i state ESTABLISHED dst [dst-ip];" command.
    */
    float avg_rtt_value = 1;
    string pacing_avg_rate = 2; //p_avg_value
    float avg_cwnd_rate = 3; //avg_cwnd_value
    float avg_retransmission_timeout_value = 4; //avg_rto_value
    float avg_byte_ack = 5;
    float avg_seg_out = 6;
    float retrans = 7; //retransmission
    float avg_mss_rate = 8; //avg_mss_rate
    float avg_ssthresh_rate  = 9; //avg_ssthresh_value
    float avg_seg_in = 10;
    string avg_send_value = 11;
    float avg_unacked_value  = 12; //unacked packets
    float avg_rcv_space_rate = 13; //avg_rcv_space
    float send_buffer_value = 14; //1 - 14 is Transfer Metrics

    /*
        15 to 29 is Disk Metrics got by using "iostat -x [Device_Name];" command.
    */
    float read_req = 15; //The number (after merges) of read requests completed per second for the device.
    float write_req = 16; //The number (after merges) of write requests completed per second for the device.
    float rkB = 17; //The number of sectors (kilobytes, megabytes) read from the device per second.
    float wkB = 18; //The number of sectors (kilobytes, megabytes) written to the device per second.
    float rrqm = 19; //The number of read requests merged per second that were queued to the device.
    float wrqm = 20; //The number of write requests merged per second that were queued to the device.
    float rrqm_perc = 21; //The percentage of read requests merged together before being sent to the device.
    float wrqm_perc = 22; //The percentage of write requests merged together before being sent to the device.
    float r_await = 23; //The average time (in milliseconds) for read requests issued to the device to  be  served.  This includes the time spent by the requests in queue and the time spent servicing them.
    float w_await = 24; //The  average  time (in milliseconds) for write requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them.
    float aqu_sz = 25; //The average queue length of the requests that were issued to the device. Note: In previous versions, this field was known as avgqu-sz.
    float rareq_sz = 26; //The average size (in kilobytes) of the read requests that were issued to the device.
    float wareq_sz = 27; //The average size (in kilobytes) of the write requests that were issued to the device.
    float svctm = 28; //The average service time (in milliseconds) for I/O requests that were  issued  to  the  device. Warning! Do not trust this field any more.  This field will be removed in a future sysstat version.
    float util = 29; //Percentage of elapsed time during which I/O requests were issued to the device (bandwidth  utilization for the device). Device saturation occurs when this value is close to 100% for devices serving requests serially.  But for devices serving requests in parallel, such as  RAID  arrays and modern SSDs, this number does not reflect their performance limits.

    /*
        30 - 36 is generated using "cat /proc/{pid}/io;" command.
        To read more go to https://man7.org/linux/man-pages/man5/proc.5.html 
        and search for "/proc/[pid]/io"
    */
    uint64 rchar = 30; //characters read; The number of bytes which this task has caused to be read from storage.
    uint64 wchar = 31; //characters written; The number of bytes which this task has caused, or shall cause to be written to disk.
    uint64 syscr = 32; //Attempt to count the number of read I/O operations—that is, system calls such as read(2) and pread(2).
    uint64 syscw = 33; //Attempt to count the number of write I/O operations—that is, system calls such as write(2) and pwrite(2).
    uint64 read_bytes = 34; //Attempt to count the number of bytes which this process really did cause to be fetched from the storage layer.  This is accurate for block-backed filesystems.
    uint64 write_bytes = 35; //Attempt to count the number of bytes which this process caused to be sent to the storage layer.
    uint64 cancelled_write_bytes = 36; //The big inaccuracy here is truncate.  If a process writes 1 MB to a file and then deletes the file, it will in fact perform no writeout.  But it will have been accounted as having caused 1 MB of write.  In other words: this field represents the number of bytes which this process caused to not happen, by truncating pagecache.  A task can cause "negative" I/O too.  If this task truncates some dirty pagecache, some I/O which another task has been accounted for (in its write_bytes) will not be happening.

    /*  37 - 86 are generated using "cat /proc/{pid}/stat;" command. 
        To read more go to https://man7.org/linux/man-pages/man5/proc.5.html 
        and search for "/proc/[pid]/stat" 
    */
    int32 pid = 37; //The process id.
    int32 ppid = 38; //The PID of the parent of this process
    int32 pgrp = 39; //The process group ID of the process. 
    int32 session = 40; //The session ID of the process.
    int32 tty_nr = 41; //The controlling terminal of the process.  (The minor device number is contained in the combination of bits 31 to 20 and 7 to 0; the major device number is in bits 15 to 8.)
    int32 tpgid = 42; //The ID of the foreground process group of the controlling terminal of the process.
    uint32 flags = 43; //The kernel flags word of the process.  For bit meanings, see the PF_* defines in the Linux kernel source file include/linux/sched.h.  Details depend on the kernel version. The format for this field was %lu before Linux 2.6.
    uint64 minflt = 44; //The number of minor faults the process has made which have not required loading a memory page from disk.
    uint64 cminflt = 45; //The number of minor faults that the process's waited-for children have made.
    uint64 majflt = 46; //The number of major faults the process has made which have required loading a memory page from disk.
    uint64 cmajflt = 47; //The number of major faults that the process's waited-for children have made.
    uint64 utime = 48; //Amount of time that this process has been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).  This includes guest time, guest_time (time spent running a virtual CPU, see below), so that applications that are not aware of the guest time field do not lose that time from their calculations.
    uint64 stime = 49; //Amount of time that this process has been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK))
    int64 cutime = 50; //Amount of time that this process's waited-for children have been scheduled in user mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)). (See also times(2).)  This includes guest time, cguest_time (time spent running a virtual CPU, see below).
    int64 cstime = 51; //Amount of time that this process's waited-for children have been scheduled in kernel mode, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
    int64 priority = 52; //(Explanation for Linux 2.6) For processes running a real-time scheduling policy (policy below; see sched_setscheduler(2)), this is the negated scheduling priority, minus one; that is, a number in the range -2 to -100, corresponding to real-time priorities 1 to 99.  
    int64 nice = 53; //The nice value (see setpriority(2)), a value in the range 19 (low priority) to -20 (high priority).
    int64 num_threads = 54; //Number of threads in this process (since Linux 2.6).  Before kernel 2.6, this field was hard coded to 0 as a placeholder for an earlier removed field.
    int64 itrealvalue = 55; //The time in jiffies before the next SIGALRM is sent to the process due to an interval timer.
    uint64 starttime = 56; //The time the process started after system boot.
    uint64 vsize = 57; //Virtual memory size in bytes.
    uint64 rss = 58; //Resident Set Size: number of pages the process has in real memory.  This is just the pages which count toward text, data, or stack space.  This does not include pages which have not been demand-loaded in, or which are swapped out.  This value is inaccurate; see /proc/[pid]/statm below.
    uint64 rsslim = 59; //Current soft limit in bytes on the rss of the process; see the description of RLIMIT_RSS in getrlimit(2).
    uint64 startcode = 60; //The address above which program text can run.
    uint64 endcode = 61; //The address below which program text can run.
    uint64 startstack = 62; //The address of the start (i.e., bottom) of the stack.
    uint64 kstkesp = 63; //The current value of ESP (stack pointer), as found in the kernel stack page for the process.
    uint64 kstkeip = 64; //The current EIP (instruction pointer).
    uint64 signal = 65; //[Obsolete] The bitmap of pending signals, displayed as a decimal number.  Obsolete, because it does not provide information on real-time signals; use /proc/[pid]/status instead.
    uint64 blocked = 66; //[Obsolete] The bitmap of blocked signals, displayed as a decimal number.  Obsolete, because it does not provide information on real-time signals; use /proc/[pid]/status instead.
    uint64 sigignore = 67; //[Obsolete] The bitmap of ignored signals, displayed as a decimal number.
    uint64 sigcatch = 68; //[Obsolete] The bitmap of caught signals, displayed as a decimal number.
    uint64 wchan = 69; //This is the "channel" in which the process is waiting.  It is the address of a location in the kernel where the process is sleeping.
    uint64 nswap = 70; //Number of pages swapped (not maintained).
    uint64 cnswap = 71; //Cumulative nswap for child processes (not maintained).
    int32 exit_signal = 72; //Signal to be sent to parent when we die.
    int32 processor = 73; //CPU number last executed on.
    uint32 rt_priority = 74; //Real-time scheduling priority, a number in the range 1 to 99 for processes scheduled under a real- time policy, or 0, for non-real-time processes (see sched_setscheduler(2)).
    uint32 policy = 75; //Scheduling policy (see sched_setscheduler(2)). Decode using the SCHED_* constants in linux/sched.h.
    uint64 delayacct_blkio_ticks = 76; //Aggregated block I/O delays, measured in clock ticks (centiseconds).
    uint64 guest_time = 77; //Guest time of the process (time spent running a virtual CPU for a guest operating system), measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
    int64 cguest_time = 78; //Guest time of the process's children, measured in clock ticks (divide by sysconf(_SC_CLK_TCK)).
    uint64 start_data = 79; //Address above which program initialized and uninitialized (BSS) data are placed.
    uint64 end_data = 80; //Address below which program initialized and uninitialized (BSS) data are placed.
    uint64 start_brk = 81; //Address above which program heap can be expanded with brk(2).
    uint64 arg_start = 82; //Address above which program command-line arguments (argv) are placed.
    uint64 arg_end = 83; //Address below program command-line arguments (argv) are placed.
    uint64 env_start = 84; //Address above which program environment is placed.
    uint64 env_end = 85; //Address below which program environment is placed.
    int32 exit_code = 86; //The thread's exit status in the form reported by waitpid(2).

    /*  
        The fields 87 - 88 are generated using following command "ps -p [pid]  -o '%cpu,%mem';"
    */
    float cpu_usage_percentage = 87; //Total CPU usuage percentage
    float mem_usage_percentage = 88; //Total Memory usuage percentage
    /*  
        The fields 89 - 91 are generated using following command "cat /proc/sys/net/ipv4/tcp_rmem". 
        You can find further documentation in https://man7.org/linux/man-pages/man7/tcp.7.html 
        and search tcp_rmem;
    */
    uint64 tcp_rcv_buffer_min = 89; //minimum size of the receive buffer used by each TCP socket.
    uint64 tcp_rcv_buffer_default = 90; //the default size of the receive buffer for a TCP socket.
    uint64 tcp_rcv_buffer_max = 91; //the maximum size of the receive buffer used by each TCP socket.
    
    /*
        The fields 92 - 94 are generated using following command "cat /proc/sys/net/ipv4/tcp_wmem". 
        You can find further documentation in https://man7.org/linux/man-pages/man7/tcp.7.html 
        and search tcp_wmem;
    */
    uint64 tcp_snd_buffer_min = 92; //minimum size of the send buffer used by each TCP socket.
    uint64 tcp_snd_buffer_default = 93; //the default size of the send buffer for a TCP socket.
    uint64 tcp_snd_buffer_max = 94; //the maximum size of the send buffer used by each TCP socket.
    
    /* Field 95 is the label of the experiment used.*/
    int32 label_value = 95; //The label of the experiment used.
}

message BottleneckLogs {
    repeated BottleneckLog logs = 1;
}